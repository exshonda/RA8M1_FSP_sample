/***********************************************************************************************************************
* Copyright (c) 2020 - 2024 Renesas Electronics Corporation and/or its affiliates
*
* SPDX-License-Identifier: BSD-3-Clause
***********************************************************************************************************************/
#include "common_utils.h"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

/** LED Pin connections */
#define LED_BLUE                       (0U)
#define LED_GREEN                      (1U)
#define LED_RED                        (2U)

extern bsp_leds_t g_bsp_leds;            // LED Structure used to blink on board LED

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    fsp_pack_version_t version = {RESET_VALUE};
    fsp_err_t err = FSP_SUCCESS;

    //extern void baremetal_ep(void);

    /** Get API version for FLEX pack information */
    R_FSP_VersionGet(&version);

    /** Print Example Project information on the Console */
    APP_PRINT(BANNER_INFO, EP_VERSION, version.version_id_b.major, version.version_id_b.minor, version.version_id_b.patch);

    APP_PRINT("\r\nThis project demonstrates the direct access and configuration of DOC SFRs.");
    APP_PRINT("\r\nThe SFRs & interrupts are configured directly to perform a comparison match.");
    APP_PRINT("\r\nThe ISR for the DOC is configured through the Interrupts tab of the FSP Configurator.");
    APP_PRINT("\r\nRed LED is turned ON if there is an expected error encountered during operation.");
    APP_PRINT("\r\nBlue LED is turned ON while program control waits for the User Defined ISR to execute.");
    APP_PRINT("\r\nGreen LED is turned ON to indicate the successful conclusion of application execution.");

    /** Run the example project code. */
    baremetal_ep();

    APP_PRINT("\r\nReached Application End..\r\n");

    R_IOPORT_PinWrite(&g_ioport_ctrl, g_bsp_leds.p_leds[LED_GREEN], BSP_IO_LEVEL_HIGH);
    R_IOPORT_PinWrite(&g_ioport_ctrl, g_bsp_leds.p_leds[LED_RED], BSP_IO_LEVEL_HIGH);

    /* Open ICU module */
    err = R_ICU_ExternalIrqOpen(&g_external_irq12_ctrl, &g_external_irq12_cfg);
    /* Handle error */
    if (FSP_SUCCESS != err)
    {
        /* ICU Open failure message */
        APP_ERR_PRINT ("\r\n**R_ICU_ExternalIrqOpen API FAILED**\r\n");
    }
    /* Open ICU module */
    err = R_ICU_ExternalIrqOpen(&g_external_irq13_ctrl, &g_external_irq13_cfg);
    /* Handle error */
    if (FSP_SUCCESS != err)
    {
        /* ICU Open failure message */
        APP_ERR_PRINT ("\r\n**R_ICU_ExternalIrqOpen API FAILED**\r\n");
    }


    /* Enable ICU module */
    err = R_ICU_ExternalIrqEnable(&g_external_irq12_ctrl);
    /* Handle error */
    if (FSP_SUCCESS != err)
    {
        /* ICU Enable failure message */
        APP_ERR_PRINT ("\r\n**R_ICU_ExternalIrqEnable API FAILED**\r\n");
    }

    /* Enable ICU module */
    err = R_ICU_ExternalIrqEnable(&g_external_irq13_ctrl);
    /* Handle error */
    if (FSP_SUCCESS != err)
    {
        /* ICU Enable failure message */
        APP_ERR_PRINT ("\r\n**R_ICU_ExternalIrqEnable API FAILED**\r\n");
    }    
    
    
    while(1){
        R_IOPORT_PinWrite(&g_ioport_ctrl, g_bsp_leds.p_leds[LED_BLUE], BSP_IO_LEVEL_LOW);

        R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_06_PIN_01, BSP_IO_LEVEL_LOW);
        R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_06_PIN_02, BSP_IO_LEVEL_LOW);
        
        APP_PRINT("Led On..\r\n");
        
        R_BSP_SoftwareDelay(500, BSP_DELAY_UNITS_MILLISECONDS);
        
        R_IOPORT_PinWrite(&g_ioport_ctrl, g_bsp_leds.p_leds[LED_BLUE], BSP_IO_LEVEL_HIGH);

        R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_06_PIN_01, BSP_IO_LEVEL_HIGH);
        R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_06_PIN_02, BSP_IO_LEVEL_HIGH);
        
        APP_PRINT("Led Off..\r\n");
        R_BSP_SoftwareDelay(500, BSP_DELAY_UNITS_MILLISECONDS);
    }
    while(1)
    {
        /* Halt the CPU */
        __WFI();
    }
#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, &g_bsp_pin_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif

void g_external_irq13_callback(external_irq_callback_args_t *p_args)
{
#if 0    
    /* Make sure it's the right interrupt*/
    if(USER_SW_IRQ_NUMBER == p_args->channel)
    {
        g_sw_press = true;
    }
#endif
    APP_PRINT("\r\n IRQ13 Handler!!");
}

void g_external_irq12_callback(external_irq_callback_args_t *p_args)
{
#if 0    
    /* Make sure it's the right interrupt*/
    if(USER_SW_IRQ_NUMBER == p_args->channel)
    {
        g_sw_press = true;
    }
#endif
    APP_PRINT("\r\n S : IRQ12 Handler!!");
}
